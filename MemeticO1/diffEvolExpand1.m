% --- Notes
% - Function for expanding a solution set based on differential evolution
% - Pre-requisite: the input solution set must have evaluated costs and must be sorted
% - If solution s1 is a leader relative to s2 which is thus a follower, this means that the cost
%   of s1 is smaller than that of s2.
% - The usage of a "grand velocity" with its amplification is only a proof
% of concept. The notion of combining velocity vectors should be extended
% to include usage of cost evaluations, vectors from different generations,
% etc.
% --- Think
% - The maximum number of new solutions that can be generated through DE is sigma_i=1^n-1,
%   where n is the number of solutions. How many new solutions should be generated? If we decide to
%   select a subset of the maximum number of possible new solutions, how do we make the selection?
%   Which "leaders" and "followers" do we choose? Does solution diversity enter this decision?
% - This version (v1) of DE is quite simplistic in this regards (i.e. selection of leaders & followers).
%   Future versions should try to make more informed decisions (leading to smaller yet more effective
%   expansions).
% - In future versions consider storing velocity, acceleration, etc. vectors for use in future generations.
%   Velocity = alpha*(leader-follower);
% --- Arguments
% - inSols: input solution set (with costs and sorted)
% - gsoParams: global stochastic optimization parameters
function solExpand = diffEvolExpand1(inSols,gsoParams)
   solExpand = inSols;
   % Extract basic information
   [yLeng xLeng] = size(inSols);
   numSols = yLeng;
   numParam = xLeng - 1; % the leftmost column holds solution costs
   % Set index of first leader (i.e. the best solution)
   li = 1;
   nsi = numSols+1; % new solution index
   % List of velocities (for average or "grand velocity")
   listVelocs = zeros(1,numParam);
   lvi=1;
   % Iterate
   while li < numSols
      leader = inSols(li,2:xLeng);
      % Search for the closest, "non-identical" follower (in other versions more followers per leader might be used)
      incfoli = firstDiffSol(leader,inSols(li+1:numSols,2:xLeng),gsoParams.minDiffLF);
      if incfoli ~= -1
         foli = li+incfoli; % add increment (incfoli is relative to the matrix subset given)
         follower = inSols(foli,2:xLeng);
         % Generate DE solution
         velocVec = gsoParams.alpha*(leader-follower);
         newSol = leader + velocVec;
         newSol = normSol(newSol,gsoParams.paramRange);  % because of <0 and >1
         % Store DE solution (set cost to -1)
         solExpand(nsi,:) = [-1 newSol];
         nsi=nsi+1;
         % Store velocity
         listVelocs(lvi,:) = velocVec;
         lvi=lvi+1;
         % Get index of next leader 
         incli = firstDiffSol(leader,inSols(li+1:numSols,2:xLeng),gsoParams.minDiffLL); % if li==0 return first solution
         if incli == -1
            li = Inf;
         else
            li = li + incli;
         end 
      else
         li = Inf;
      end
   end
   % Generate the "grand velocity"
   grandVeloc = gsoParams.gvAmplify*mean(listVelocs);
   firstLeader = inSols(1,2:xLeng);
   newSol = firstLeader + grandVeloc;
   newSol = normSol(newSol,gsoParams.paramRange);  % because of <0 and >1
   solExpand(nsi,:) = [-1 newSol];
   % Display the number of new solutions generated
   if gsoParams.vis_verbose == 1
       numExpand = nsi-numSols;
       disp(['Number of new solutions generated by differential evolution: ' num2str(numExpand)]); 
   end
   % Apply fixed parameters
   solExpand = fixSolParam(solExpand,gsoParams.fixParams);
   
   
   